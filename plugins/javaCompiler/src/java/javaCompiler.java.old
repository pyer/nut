package ab.nut.plugins;

/*
Javac.exe is used by this plugin
--------------------------------

Usage: javac <options> <source files>
where possible options include:
  -g                         Generate all debugging info
  -g:none                    Generate no debugging info
  -g:{lines,vars,source}     Generate only some debugging info
  -nowarn                    Generate no warnings
  -verbose                   Output messages about what the compiler is doing
  -deprecation               Output source locations where deprecated APIs are used
  -classpath <path>          Specify where to find user class files and annotation processors
  -cp <path>                 Specify where to find user class files and annotation processors
  -sourcepath <path>         Specify where to find input source files
  -bootclasspath <path>      Override location of bootstrap class files
  -extdirs <dirs>            Override location of installed extensions
  -endorseddirs <dirs>       Override location of endorsed standards path
  -proc:{none,only}          Control whether annotation processing and/or compilation is done.
  -processor <class1>[,<class2>,<class3>...]Names of the annotation processors to run; bypasses default discovery process
  -processorpath <path>      Specify where to find annotation processors
  -d <directory>             Specify where to place generated class files
  -s <directory>             Specify where to place generated source files
  -implicit:{none,class}     Specify whether or not to generate class files for implicitly referenced files 
  -encoding <encoding>       Specify character encoding used by source files
  -source <release>          Provide source compatibility with specified release
  -target <release>          Generate class files for specific VM version
  -version                   Version information
  -help                      Print a synopsis of standard options
  -Akey[=value]              Options to pass to annotation processors
  -X                         Print a synopsis of nonstandard options
  -J<flag>                   Pass <flag> directly to the runtime system

*/

import nut.logging.Log;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.StringReader;

import java.lang.InterruptedException;
import java.lang.Process;
import java.lang.Runtime;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

/**
 * Compiles application sources
 *
 */
public class javaCompiler
{
    /** Instance logger */
    private static Log log;

    public static void setLog(Log pluginLog)
    {
        log = pluginLog;
    }

    public static void execute(Properties pluginContext, List dependencies, List testDependencies )
        throws Exception
    {
        String basedir = (String)pluginContext.getProperty( "basedir" );

        String buildDirectory      = (String)pluginContext.getProperty( "build.directory" );
        String sourceDirectory     = (String)pluginContext.getProperty( "build.sourceDirectory" );
        String testSourceDirectory = (String)pluginContext.getProperty( "build.testSourceDirectory" );
        String outputDirectory     = (String)pluginContext.getProperty( "build.outputDirectory" );
        String testOutputDirectory = (String)pluginContext.getProperty( "build.testOutputDirectory" );

        log.debug( "build.directory           = " + buildDirectory );
        log.debug( "build.sourceDirectory     = " + sourceDirectory );
        log.debug( "build.testSourceDirectory = " + testSourceDirectory );
        log.debug( "build.outputDirectory     = " + outputDirectory );
        log.debug( "build.testOutputDirectory = " + testOutputDirectory );
/*        
        if ( dependencies!=null )
        {
            for ( int i = 0; i < dependencies.size(); i++ )
            {
                log.debug( "project.dependency   = " + (String)(dependencies.get(i)) );
            }
        }
*/

        /* Compiling sources */
        File outputDir = new File( basedir + File.separator + outputDirectory );
        if ( !outputDir.exists() )
        {
            outputDir.mkdirs();
        }

        //List sources = sourceFiles( new File( basedir + File.separator + sourceDirectory ) );
        List sources = sourceFiles( new File( sourceDirectory ) );
        if ( sources.isEmpty() )
        {
            log.warn( "Source directory " + sourceDirectory + " is empty" );
        }
        else
        {
            log.info( "   Compiling " + sourceDirectory );
            compile( sources, dependencies, basedir + File.separator + sourceDirectory, basedir + File.separator + outputDirectory );
        }
        
        /* Compiling test sources */
        File testOutputDir = new File( basedir + File.separator + testOutputDirectory );
        if ( !testOutputDir.exists() )
        {
            testOutputDir.mkdirs();
        }
        
        List testSources = sourceFiles( new File( basedir + File.separator + testSourceDirectory ) );
        //testSources.addAll(sources);
        if ( testSources.isEmpty() )
        {
            log.warn( "Test source directory " + testSourceDirectory + " is empty" );
        }
        else
        {
            if ( !testDependencies.isEmpty() )
                dependencies.addAll(testDependencies);
            dependencies.add( basedir + File.separator + outputDirectory );
            log.info( "   Compiling " + testSourceDirectory );
            compile( testSources, dependencies, basedir + File.separator + testSourceDirectory, basedir + File.separator + testOutputDirectory );
        }
        
    }

    private static List sourceFiles( File sourceDir )
    {
        List sources = new LinkedList();
        if( !sourceDir.exists() )
            return sources;

        boolean found = false;
        String[] sourcesList = sourceDir.list();
        log.debug( "Source directory is " + sourceDir.getAbsolutePath() );

        //sources.add( (String)sourceDir.getAbsolutePath() );
        for (int i=0; i<sourcesList.length; i++)
        {
            File child = new File(sourceDir, sourcesList[i]);
            if (child.isDirectory())
            {
                //sources.addAll( sourceFiles( child ) );
                sourceFiles( child );
            }
            else
            {
                if ( child.getName().endsWith(".java") )
                {
                     log.debug( "- " + child.getAbsolutePath() );
                     sources.add( child.getAbsolutePath() );
                     //found = true;
                }
            }

        }

        if( found )
            sources.add( (String)sourceDir.getAbsolutePath() );
        return sources;
    }

    private static void compile(List sources, List dependencies, String sourceDirectory, String outputDirectory)
        throws Exception
    {
        log.debug("      from \'" + sourceDirectory + "\' to \'" + outputDirectory + "\'" );
        log.debug( sources.toString() );
        List args = new ArrayList();
        // Set compiler
        args.add( "javac" );
        // Set output
        args.add( "-d" );
        args.add( outputDirectory );
        //if ( config.isOptimize() )
            args.add( "-O" );
/*
        // ----------------------------------------------------------------------
        if ( config.isDebug() )
        {
            if ( StringUtils.isNotEmpty( config.getDebugLevel() ) )
            {
                args.add( "-g:" + config.getDebugLevel() );
            }
            else
            {
                args.add( "-g" );
            }
        }

        if ( config.isVerbose() )
        {
            args.add( "-verbose" );
        }

        // ----------------------------------------------------------------------
        if ( config.isShowDeprecation() )
        {
            args.add( "-deprecation" );

            // This is required to actually display the deprecation messages
            config.setShowWarnings( true );
        }

        if ( !config.isShowWarnings() )
        {
            args.add( "-nowarn" );
        }

        // ----------------------------------------------------------------------

        if ( !suppressEncoding( config ) && !StringUtils.isEmpty( config.getSourceEncoding() ) )
        {
            args.add( "-encoding" );
            args.add( config.getSourceEncoding() );
        }
*/
        // ----------------------------------------------------------------------
        // Set the class and source paths
        // ----------------------------------------------------------------------
/*
        //List classpathEntries = config.getClasspathEntries();
        if ( ( classpathEntries != null ) && !classpathEntries.isEmpty() )
        {
            args.add( "-classpath" );

            args.add( getPathString( classpathEntries ) );
        }
*/
        args.add( "-classpath" );
        String classpathEntries = outputDirectory;
        for ( int i = 0; i < dependencies.size(); i++ )
        {
            classpathEntries = classpathEntries + File.pathSeparator + (String)(dependencies.get(i));
        }
        args.add( classpathEntries );
        log.debug( "-classpath " + classpathEntries );

        args.add( "-sourcepath" );
        args.add( sourceDirectory );
        // and the sources, at last
        for ( int i = 0; i < sources.size(); i++ )
        {
            // args.add( (String)(sources.get(i)) + String.valueOf(File.separatorChar) + "*.java" );
            args.add( (String)(sources.get(i)) );
        }

        // ----------------------------------------------------------------------
        // build the command line
        log.debug( args.toString() );
        String[] command = (String[]) args.toArray( new String[ args.size() ] );
        try
        {
            Process child = Runtime.getRuntime().exec(command);
            InputStream in = child.getErrorStream();
            List messages = parseModernStream( in );
            if ( child.exitValue() != 0 )
            {
                if( !messages.isEmpty() )
                {
                    for ( int i = 0; i < messages.size(); i++ )
                    {
                        log.error( (String)(messages.get(i)) );
                    }
                }
                throw new Exception();
            }
        }
        catch ( IOException e )
        {
            log.error( "Failed to compile. Reason: " + e.getMessage(), e );
            throw new Exception();
        }
    }

    /**
     * Parse the output from the compiler into a list of CompilerError objects
     *
     * @param input The output of the compiler
     * @return List of CompilerError objects
     * @throws IOException
     */
    private static List parseModernStream( InputStream in )
        throws IOException
    {
        List errors = new ArrayList();
        String line;
        BufferedReader br = new BufferedReader(new InputStreamReader(in));
            // cleanup the buffer
            StringBuffer buffer = new StringBuffer(); // this is quicker than clearing it
            // most errors terminate with the '^' char
            do
            {
                line = br.readLine();

                if ( line == null )
                {
                    return errors;
                }
                //log.warnx(line);
                // TODO: there should be a better way to parse these
                if ( ( buffer.length() == 0 ) && line.startsWith( "error: " ) )
                {
                    errors.add( line );
                }
                else if ( ( buffer.length() == 0 ) && line.startsWith( "Note: " ) )
                {
                    // skip this one - it is JDK 1.5 telling us that the interface is deprecated.
                }
                else
                {
                    buffer.append( line );
                log.warn(line);
                }
            }
            while ( !line.endsWith( "^" ) );

            // add the error bean
            errors.add( buffer.toString() );
        return errors;
    }


}
